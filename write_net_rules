#!/bin/sh -e

# This script is run to create persistent network device naming rules
# based on properties of the device.
# If the interface needs to be renamed, INTERFACE_NEW=<name> will be printed
# on stdout to allow udev to IMPORT it.

# variables used to communicate:
#   MATCHADDR             MAC address used for the match
#   MATCHID               bus_id used for the match
#   MATCHDEVID            dev_id used for the match
#   MATCHDRV              driver name used for the match
#   MATCHIFTYPE           interface type match
#   COMMENT               comment to add to the generated rule
#   INTERFACE_NAME        requested name supplied by external tool
#   INTERFACE_NEW         new interface name returned by rule writer

: ${RULES_FILE='/etc/udev/rules.d/70-persistent-net.rules'}
: ${RUNDIR="/run/udev/"}
: ${RULES_LOCK="$RUNDIR/.lock-${RULES_FILE##*/}"}

PATH='/sbin:/bin'


# Read a single line from file $1 in the $DEVPATH directory.
# The function must not return an error even if the file does not exist.
sysread() {
    local file="$1"
    local value
    test -e "/sys$DEVPATH/$file"      || return 0
    read value < "/sys$DEVPATH/$file" || return 0
    echo "$value"
}



sysreadlink() {
    local file="$1"
    test -e "/sys$DEVPATH/$file" || return 0
    readlink -f /sys$DEVPATH/$file 2> /dev/null || true
}



# Return true if a directory is writeable.
writeable() {
    ln -s test-link $1/.is-writeable 2> /dev/null && {
        rm -f $1/.is-writeable
        return 0
    }
    return 1
}



# Create a lock file for the current rules file.
lock_rules_file() {
    local RETRY=30

    while ! mkdir $RULES_LOCK 2> /dev/null; do
        test $RETRY -eq 0 && {
            echo "Cannot lock $RULES_FILE!" >&2
            exit 2
        }
        sleep 1
        RETRY=$(($RETRY - 1))
    done
}



unlock_rules_file() {
    test "$RULES_LOCK" || return 0
    rm -d $RULES_LOCK || true
}



# Choose the real rules file if it is writeable or a temporary file if not.
# Both files should be checked later when looking for existing rules.
choose_rules_file() {
    local tmp_rules_file="$RUNDIR/tmp-rules--${RULES_FILE##*/}"

    test -e "$RULES_FILE" -o -e "$tmp_rules_file" || PRINT_HEADER=1
    test -d "${RULES_FILE%/*}" || writeable ${RULES_FILE%/rules.d/*} && mkdir -p "${RULES_FILE%/*}"

    if writeable ${RULES_FILE%/*} ; then
        RO_RULES_FILE='/dev/null'
    else
        RO_RULES_FILE=$RULES_FILE
        RULES_FILE=$tmp_rules_file
    fi
}



# Return the name of the first free device.
raw_find_next_available() {
    local links="$1"
    local basename=${links%%[ 0-9]*}
    local max=-1

    for name in $links; do
        local num=${name#$basename}
        test "$num"            || num=0
        test "$num" -gt "$max" && max=$num
    done

    local max=$(($max + 1))
    # "name0" actually is just "name"
    test "$max" -eq 0 && return
    echo "$max"
}



# Find all rules matching a key (with action) and a pattern.
find_all_rules() {
    local key="$1"
    local linkre="$2"
    local match="$3"
    local search='.*[[:space:],]'"$key"'"('"$linkre"')".*'

    sed -n -r -e 's/^#.*//' -e "${match}s/${search}/\1/p" $RO_RULES_FILE $(test -e $RULES_FILE && echo $RULES_FILE) 2>/dev/null
}



interface_name_taken() {
    local value="$(find_all_rules 'NAME=' $INTERFACE)"
    test "$value" && return 0
    return 1
}



find_next_available() {
    raw_find_next_available "$(find_all_rules 'NAME=' "$1")" 
}



write_rule() {
    local MATCH="$1"
    local NAME="$2"
    local COMMENT="$3"

    test "$PRINT_HEADER" && {
        cat <<- EOF >> $RULES_FILE
            # This file was automatically generated by the $0
            # program, run by the persistent-net-generator.rules rules file.
            #
            # You can modify it, as long as you keep each rule on a single
            # line, and change only the value of the NAME= key.

EOF
    }
    test "$COMMENT" && echo "# $COMMENT" >> $RULES_FILE
    echo "SUBSYSTEM==\"net\", ACTION==\"add\"$MATCH, NAME=\"$NAME\"" >> $RULES_FILE
}



#
# Beginning of the script
#

test -z "$INTERFACE" && {
    echo "missing \$INTERFACE" >&2
    exit 1
}

# Prevent concurrent processes from modifying the file at the same time.
lock_rules_file

# Check if the rules file is writeable.
choose_rules_file

# the DRIVERS key is needed to not match bridges and VLAN sub-interfaces
test "$MATCHADDR"   && MATCH="$match, DRIVERS==\"?*\", ATTR{address}==\"$MATCHADDR\""
test "$MATCHDRV"    && MATCH="$match, DRIVERS==\"$MATCHDRV\""
test "$MATCHDEVID"  && MATCH="$match, ATTR{dev_id}==\"$MATCHDEVID\""
test "$MATCHID"     && MATCH="$match, KERNELS==\"$MATCHID\""
test "$MATCHIFTYPE" && MATCH="$match, ATTR{type}==\"$MATCHIFTYPE\""
test -z "$MATCH" && {
    echo "missing valid match" >&2
    unlock_rules_file
    exit 1
}

BASENAME=${INTERFACE%%[0-9]*}
MATCH="$MATCH, KERNEL==\"$BASENAME*\""

if test "$INTERFACE_NAME" ; then
    # external tools may request a custom name
    COMMENT="$COMMENT (custom name provided by external tool)"
    test "$INTERFACE_NAME" != "$INTERFACE" && {
        INTERFACE=$INTERFACE_NAME;
        echo "INTERFACE_NEW=$INTERFACE"
    }
else
    # if a rule using the current name already exists, find a new name
    interface_name_taken && {
        INTERFACE="$BASENAME$(find_next_available "$BASENAME[0-9]*")"

        # prevent INTERFACE from being "eth" instead of "eth0"
        test "$INTERFACE" = "${INTERFACE%%[ \[\]0-9]*}" && INTERFACE=${INTERFACE}0
        echo "INTERFACE_NEW=$INTERFACE"
    }
fi

write_rule "$MATCH" "$INTERFACE" "$COMMENT"

unlock_rules_file

exit 0
